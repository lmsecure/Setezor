{% import 'modals/tools_modal_constructor.html' as modal %}

{{ modal.create_modal('bruteModalWindow', 'Brute Tool', 'https://help.setezor.net/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B.html#brute') }}

<script>
const BruteUI = {
  getStyles() {
    return `
      <style>
        .brute-tool-section {
          background: #f8f9fa;
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 15px;
          border: 1px solid #e9ecef;
        }
        .brute-tool-section h6 {
          font-size: 0.85rem;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: #6c757d;
          margin-bottom: 10px;
          font-weight: bold;
          display: flex;
          align-items: center;
        }
        .brute-tool-section h6 i { 
          margin-right: 8px; 
        }
      </style>
    `;
  },

  buildParams(prefix) {
    return `
      ${this.getStyles()}
      ${this.buildWordlistUpload(prefix)}
    `;
  },

  buildWordlistUpload(prefix) {
    return `
      <div class="brute-tool-section">
        <h6><i class="bi bi-file-text"></i> ${i18next.t("Upload wordlist file (optional)")}</h6>
        <div class="form-text text-muted mb-2">
          ${i18next.t("Upload a .txt file with passwords or usernames (max 10MB)")}
        </div>
        <input class="form-control" 
               type="file" 
               id="${prefix}fileUpload" 
               accept=".txt"
               data-max-size="10485760">
        <small class="form-text text-muted mt-1">
          ${i18next.t("If no file is uploaded, default wordlist will be used")}
        </small>
      </div>
    `;
  }
};

const BruteHandlers = {
  uploadedFile: null,

  setupFileUpload(prefix) {
    const fileInput = document.getElementById(`${prefix}fileUpload`);
    if (!fileInput) return;

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      const maxSize = parseInt(fileInput.dataset.maxSize || 10485760);
      
      if (file) {
        if (file.size > maxSize) {
          create_toast('Error', i18next.t('File size too large. Maximum 10MB allowed.'), 'error');
          fileInput.value = '';
          this.uploadedFile = null;
          return;
        }
        this.uploadedFile = file;
      } else {
        this.uploadedFile = null;
      }
    });
  },

  async readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = (e) => reject(e);
      reader.readAsDataURL(file);
    });
  },

  handleNodeModal(instance, node) {
    const prefix = instance.prefix;
    
    instance.reset();
    
    const domainInput = document.getElementById(`${prefix}inputDomain`);
    if (domainInput) {
      domainInput.value = node.label || '';
    }
    
    window[`show_${instance.modalId}`]();
  },

  handlePrefill(instance, rows = [], prefillParams = {}) {
    const prefix = instance.prefix;
    
    instance.reset();
    
    const targetTab = document.getElementById(`${prefix}target-tab`);
    if (targetTab) {
      const tab = new bootstrap.Tab(targetTab);
      tab.show();
    }
    const uniqueTargets = [...new Set(
      rows
        .map(row => (row.domain || row.target || '').trim())
        .filter(Boolean)
    )];

    uniqueTargets.forEach((target, index) => {
      if (index === 0) {
        const domainInput = document.getElementById(`${prefix}inputDomain`);
        if (domainInput) domainInput.value = target;
      } else {
        instance.addInputField('domain_only');
        
        const container = document.getElementById(`${prefix}InputContainer`);
        const lastGroup = container?.lastElementChild;
        
        if (lastGroup) {
          const input = lastGroup.querySelector('.domain');
          if (input) input.value = target;
        }
      }
    });

    if (prefillParams?.agent_id) {
      instance.state.overrides.agent_id = prefillParams.agent_id;
    }
    
    window[`show_${instance.modalId}`]();
  },

  handleTextareaPrefill(instance, lines) {
    const prefix = instance.prefix;
    const textarea = document.getElementById(`${prefix}textareaInput`);
    
    if (textarea) {
      textarea.value = lines.join('\n');
    }
  },

  // Получение конфигурации таблицы базы данных (только домены)
  getDatabaseTableConfig() {
    return {
      columns: [
        { 
          title: "Select", 
          field: "selected", 
          formatter: "rowSelection", 
          titleFormatter: "rowSelection", 
          hozAlign: "center", 
          headerHozAlign: "center", 
          headerSort: false,
          width: 50
        },
        { 
          title: "Domain", 
          field: "domain", 
          headerFilter: "input", 
          headerFilterPlaceholder: "Search domain..." 
        }
      ],
      filter: [
        { field: "domain", type: "!=", value: "" }
      ]
    };
  },

  handleDatabaseSelection(instance, rows) {
    const prefix = instance.prefix;
    
    // Переключаемся на вкладку database
    const databaseTab = document.getElementById(`${prefix}database-tab`);
    if (databaseTab) {
      databaseTab.click();
      
      setTimeout(() => {
        if (instance.databaseTable) {
          instance.databaseTable.setData().then(() => {
            setTimeout(() => {
              const rowsToSelect = [];
              const tableData = instance.databaseTable.getData();
              
              rows.forEach(row => {
                const match = tableData.find(tableRow => 
                  tableRow.domain === (row.domain || row.ipaddr || '')
                );
                if (match) rowsToSelect.push(match);
              });
              
              if (rowsToSelect.length > 0) {
                instance.databaseTable.selectRow(rowsToSelect);
                // Синхронизируем выбранные цели
                instance.syncDatabaseTargetsFromTable();
              }
            }, 200);
          });
        }
      }, 300);
    }
  }
};

class BruteScanner {
  constructor(prefix) {
    this.prefix = prefix;
    this.fileHandler = BruteHandlers;
  }

  getBaseParams() {
    const agentId = window.agentData?.default_agent;
    const overrideAgent = this.instance?.state?.overrides?.agent_id;

    const agent_id = overrideAgent || agentId;

    if (!agent_id) {
      throw new Error("Please select an Agent");
    }

    return {
      agent_id: String(agent_id),
      crt_sh: false
    };
  }

  async bruteTargets(targets) {
    const baseParams = this.getBaseParams();
    const tasks = [];
    let dict_file = "";

    if (this.fileHandler.uploadedFile) {
      try {
        dict_file = await this.fileHandler.readFileAsBase64(this.fileHandler.uploadedFile);
      } catch (error) {
        console.error('Error reading file:', error);
        create_toast('Error', i18next.t('Error reading file. Please try again.'), 'error');
        throw error;
      }
    }

    for (const target of targets) {
      let targetValue = '';
      
      if (typeof target === 'string') {
        targetValue = target;
      } else {
        targetValue = target.domain || target.target || '';
      }
      
      if (!targetValue) continue;
      
      const payload = {
        ...baseParams,
        domain: String(targetValue).trim(),
        ...(dict_file ? { dict_file } : {})
      };

      tasks.push({
        endpoint: '/api/v1/task/sd_find',
        payload
      });
    }

    if (tasks.length === 0) return [];

    const result = await window.executeToolTasks({
      tasks,
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Brute scan failed');
    }

    return result.responses;
  }

  async bruteScope(scopeId) {
    const baseParams = this.getBaseParams();
    let dict_file = "";

    if (this.fileHandler.uploadedFile) {
      try {
        dict_file = await this.fileHandler.readFileAsBase64(this.fileHandler.uploadedFile);
      } catch (error) {
        console.error('Error reading file:', error);
        create_toast('Error', i18next.t('Error reading file. Please try again.'), 'error');
        throw error;
      }
    }

    const payload = {
      ...baseParams,
      scope_id: String(scopeId),
      ...(dict_file ? { dict_file } : {})
    };

    const result = await window.executeToolTasks({
      tasks: [{
        endpoint: '/api/v1/task/sd_find',
        payload
      }],
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Brute scope scan failed');
    }

    return result.responses[0];
  }
}

ToolModalBuilder.register('bruteModalWindow', {
  prefix: 'brute_',
  
  tabs: [
    { id: 'target', label: i18next.t('Target'), targetType: 'domain_only' },
    { id: 'scope', label: i18next.t('Scope') },
    { id: 'database', label: i18next.t('Database') },
    //{ id: 'textarea', label: i18next.t('Textarea'), placeholder: 'example.com' },
  ],
  
  toolParams: (prefix) => BruteUI.buildParams(prefix),

  // Добавляем processor для доменов
  databaseProcessor: 'domainOnly',
  databaseOutputFormat: 'array',

  // Добавляем метод syncDatabaseTargetsFromTable для синхронизации выбранных строк
  syncDatabaseTargetsFromTable() {
    if (!this.databaseTable) return;
    
    const selectedRows = this.databaseTable.getSelectedRows();
    const newSelectedTargets = {};
    
    selectedRows.forEach(row => {
      const rowData = row.getData();
      const domain = rowData.domain;
      
      if (domain) {
        newSelectedTargets[domain] = {
          domain: domain,
          ip: rowData.ipaddr || '',
          ports: []
        };
      }
    });
    
    this.state.selectedDatabaseTargets = newSelectedTargets;
  },

  getDatabaseTableConfig() {
    return BruteHandlers.getDatabaseTableConfig();
  },

  onInit(instance) {
    const prefix = instance.prefix;

    BruteHandlers.instance = instance;
    BruteHandlers.setupFileUpload(prefix);

    // Инициализация таблицы базы данных при переключении на вкладку database
    const dbTabTrigger = document.getElementById(`${prefix}database-tab`);
    if (dbTabTrigger) {
      let tableInitialized = false;
      
      dbTabTrigger.addEventListener('shown.bs.tab', () => {
        if (!tableInitialized) {
          // Используем метод initDatabaseTable из экземпляра
          instance.initDatabaseTable();
          tableInitialized = true;
          
          // Настраиваем обработчик выбора строк в таблице
          setTimeout(() => {
            if (instance.databaseTable) {
              // Сохраняем оригинальный обработчик
              const originalRowSelectionChanged = instance.databaseTable.options.rowSelectionChanged;
              
              // Переопределяем обработчик
              instance.databaseTable.options.rowSelectionChanged = function(data, rows) {
                // Вызываем оригинальный обработчик если он был
                if (originalRowSelectionChanged) {
                  originalRowSelectionChanged(data, rows);
                }
                
                // Синхронизируем выбранные цели
                instance.syncDatabaseTargetsFromTable();
              };
            }
          }, 100);
        }
      });
    }

    window.brute_script_modal_to_node = (node) => {
      BruteHandlers.handleNodeModal(instance, node);
    };

    window.brute_start_with_prefill = (rows, prefillParams) => {
      BruteHandlers.handlePrefill(instance, rows, prefillParams);
    };

    window.brute_script_modal_to_info_tabs = async (rows) => {
      BruteHandlers.handlePrefill(instance, rows);
    };

    window.brute_script_modal_to_database = async (rows) => {
      BruteHandlers.handleDatabaseSelection(instance, rows);
    };

    window.brute_prefill_textarea = (lines) => {
      BruteHandlers.handleTextareaPrefill(instance, lines);
    };
  },

  onReset(instance) {
    const prefix = instance.prefix;

    const fileInput = document.getElementById(`${prefix}fileUpload`);
    if (fileInput) {
      fileInput.value = '';
    }
    BruteHandlers.uploadedFile = null;

    const container = document.getElementById(`${prefix}InputContainer`);
    if (container) {
      container.innerHTML = '';
    }
    
    const domainInput = document.getElementById(`${prefix}inputDomain`);
    if (domainInput) {
      domainInput.value = '';
    }

    const textarea = document.getElementById(`${prefix}textareaInput`);
    if (textarea) {
      textarea.value = '';
    }

    if (instance.databaseTable) {
      instance.databaseTable.deselectRow();
    }

    // Сбрасываем выбранные цели из базы данных
    instance.state.selectedDatabaseTargets = {};

    instance.state.overrides = {};
  },

  async onStart(instance) {
    const scanner = new BruteScanner(instance.prefix);
    scanner.instance = instance;
    scanner.fileHandler = BruteHandlers;
    
    try {
      const tabId = instance.getActiveTab();
      let result;

      if (tabId === 'scope') {
        if (!instance.state.selectedScopeId) {
          create_toast('Warning', i18next.t('Please select a scope'), 'warning');
          return;
        }
        result = await scanner.bruteScope(instance.state.selectedScopeId);
      } else if (tabId === 'database') {
        // Синхронизируем выбранные цели перед началом сканирования
        instance.syncDatabaseTargetsFromTable();
        const targets = Object.values(instance.state.selectedDatabaseTargets || {}).map(item => item.domain);
        const valid = targets.filter(t => t && !t.match(/^\d+\.\d+\.\d+\.\d+$/));
        if (!valid.length) {
          create_toast('Error', i18next.t('No valid domains found'), 'error');
          return;
        }
        result = await scanner.bruteTargets(valid);
      } else {
        const rawTargets = instance.getTargets();
        const valid = rawTargets
          .map(t => typeof t === 'string' ? t : (t.domain || t.target))
          .filter(t => t && !t.match(/^\d+\.\d+\.\d+\.\d+$/));
        if (!valid.length) {
          create_toast('Error', i18next.t('No valid domains found'), 'error');
          return;
        }
        result = await scanner.bruteTargets(valid);
      }
      
      if (result !== null) {
        window[`close_${instance.modalId}`]();
      }
    } catch (error) {
      console.error('Failed to start brute scan:', error);
      create_toast('Error', error.message || i18next.t('Failed to start scan'), 'error');
    }
  }
});
</script>