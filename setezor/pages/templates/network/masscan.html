{% import 'modals/tools_modal_constructor.html' as modal %}

{{ modal.create_modal('masscanModalWindow', 'Masscan', 'https://help.setezor.net/Инструменты.html#masscan') }}

<script>
const MasscanUI = {

  getStyles() {
    return `
      <style>
        .masscan-tool-section {
          background: #f8f9fa;
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 15px;
          border: 1px solid #e9ecef;
        }
        .masscan-tool-section h6 {
          font-size: 0.85rem;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: #6c757d;
          margin-bottom: 10px;
          font-weight: bold;
          display: flex;
          align-items: center;
        }
        .masscan-tool-section h6 i { 
          margin-right: 8px; 
        }
        .masscan-switch-row {
          margin-bottom: 8px;
          padding: 6px 0;
          border-bottom: 1px solid #e9ecef;
        }
        .masscan-switch-row:last-child {
          border-bottom: none;
          margin-bottom: 0;
        }
        .masscan-row-sections {
          display: flex;
          gap: 15px;
        }
        .masscan-row-sections > * {
          flex: 1;
        }
      </style>
    `;
  },

  buildParams(prefix) {
    return `
      ${this.getStyles()}
      ${this.buildSwitchOptions(prefix)}
      ${this.buildProtocolAndFormatRow(prefix)}
      ${this.buildWaitSlider(prefix)}
      ${this.buildParseButton(prefix)}
    `;
  },

  buildSwitchOptions(prefix) {
    return `
      <div class="masscan-tool-section">
        <h6><i class="bi bi-gear-fill"></i> ${i18next.t("Scan Options")}</h6>
        
        <!-- Порты -->
        <div class="masscan-switch-row d-flex justify-content-between align-items-center">
          <div class="form-check form-switch" style="flex: 1">
            <input class="form-check-input" type="checkbox" id="${prefix}masscanPortsScan">
            <label class="form-check-label" for="${prefix}masscanPortsScan">
              ${i18next.t('Ports')}
            </label>
          </div>
          <div style="width: 55%">
            <datalist id="${prefix}masscanPortsSelectorList">
              <option hidden disabled value="1"></option>
              <option value="80,443,8080,8443" data-i18n="web ports"></option>
              <option value="25,465,587,110,143,993,995" data-i18n="email ports"></option>
              <option value="0-65535" data-i18n="All"></option>
            </datalist>
            <input type="text" 
                   list="${prefix}masscanPortsSelectorList" 
                   id="${prefix}masscanPortsSelector" 
                   name="ports" 
                   class="form-control form-control-sm" 
                   data-i18n-placeholder="Ports" 
                   disabled />
          </div>
        </div>

        <!-- Source Port -->
        <div class="masscan-switch-row d-flex justify-content-between align-items-center">
          <div class="form-check form-switch" style="flex: 1">
            <input class="form-check-input" type="checkbox" id="${prefix}sourcePortScan">
            <label class="form-check-label" for="${prefix}sourcePortScan">
              ${i18next.t('Source Port')}
            </label>
          </div>
          <div style="width: 55%">
            <input type="text" 
                   id="${prefix}masscanSourcePortSelector" 
                   name="source_port" 
                   class="form-control form-control-sm"
                   data-i18n-placeholder="Source Port" 
                   disabled />
          </div>
        </div>

        <!-- Max Rate -->
        <div class="masscan-switch-row d-flex justify-content-between align-items-center">
          <div class="form-check form-switch" style="flex: 1">
            <input class="form-check-input" type="checkbox" id="${prefix}maxRate">
            <label class="form-check-label" for="${prefix}maxRate">
              ${i18next.t('maxRate')}
            </label>
          </div>
          <div style="width: 55%">
            <input type="text" 
                   id="${prefix}masscanMaxRateSelector" 
                   name="max_rate" 
                   class="form-control form-control-sm"
                   data-i18n-placeholder="maxRate" 
                   disabled />
          </div>
        </div>
      </div>
    `;
  },

  buildProtocolAndFormatRow(prefix) {
    return `
      <div class="masscan-row-sections">
        <!-- Протокол -->
        <div class="masscan-tool-section">
          <h6><i class="bi bi-wifi"></i> ${i18next.t('Protocol')}</h6>
          <div class="d-flex justify-content-center">
            <div class="btn-group w-100" role="group">
              <div class="form-check" data-bs-toggle="tooltip" data-bs-placement="top" title="TCP Protocol">
                <input class="btn-check" type="radio"
                       name="${prefix}protocol"
                       id="${prefix}protocolTcp"
                       value="tcp"
                       checked>
                <label class="btn btn-outline-primary" for="${prefix}protocolTcp">TCP</label>
              </div>
              <div class="form-check" data-bs-toggle="tooltip" data-bs-placement="top" title="UDP Protocol">
                <input class="btn-check" type="radio"
                       name="${prefix}protocol"
                       id="${prefix}protocolUdp"
                       value="udp">
                <label class="btn btn-outline-primary" for="${prefix}protocolUdp">UDP</label>
              </div>
            </div>
          </div>
        </div>

        <!-- Формат вывода -->
        <div class="masscan-tool-section">
          <h6><i class="bi bi-file-earmark-text"></i> ${i18next.t('Output Format')}</h6>
          <div class="d-flex justify-content-center">
            <div class="btn-group w-100" role="group">
              <div class="form-check" data-bs-toggle="tooltip" data-bs-placement="top" data-i18n-title="List format">
                <input class="btn-check" type="radio" name="${prefix}format" id="${prefix}ol" value="oL" autocomplete="off">
                <label class="btn btn-outline-primary" for="${prefix}ol">List</label>
              </div>
              <div class="form-check" data-bs-toggle="tooltip" data-bs-placement="top" data-i18n-title="XML format">
                <input class="btn-check" type="radio" name="${prefix}format" id="${prefix}ox" value="oX" autocomplete="off">
                <label class="btn btn-outline-primary" for="${prefix}ox">XML</label>
              </div>
              <div class="form-check" data-bs-toggle="tooltip" data-bs-placement="top" data-i18n-title="Json format">
                <input class="btn-check" type="radio" name="${prefix}format" id="${prefix}oj" value="oJ" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="${prefix}oj">JSON</label>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  },

  buildWaitSlider(prefix) {
    return `
      <div class="masscan-tool-section">
        <h6><i class="bi bi-clock"></i> ${i18next.t('Wait after scan')}</h6>
        <div class="px-2">
          <div class="d-flex justify-content-between mb-1">
            <small class="text-muted">0s</small>
            <small class="text-muted">10s</small>
            <small class="text-muted">20s</small>
          </div>
          <input type="range" class="form-range" name="${prefix}wait" 
                 min="0" max="20" step="1" id="${prefix}masscanWaitRange" value="10">
          <div class="text-center mt-2">
            <span class="badge bg-secondary" id="${prefix}waitValue">10</span>
            <small class="text-muted ms-2">seconds</small>
          </div>
        </div>
      </div>
    `;
  },

  buildParseButton(prefix) {
    return `
        <button class="btn btn-primary w-100 shadow-sm" id="${prefix}parseLogsBtn">
          <i class="bi bi-file-earmark-arrow-down me-2"></i>${i18next.t('Parse logs')}
        </button>
    `;
  }
};

const MasscanSwitches = {

  setupAll(prefix, instance) {
    this.setupPortsSwitch(prefix, instance);
    this.setupSourcePortSwitch(prefix);
    this.setupMaxRateSwitch(prefix);
    this.setupWaitSlider(prefix);
  },

  setupPortsSwitch(prefix, instance) {
    const portSwitch = document.getElementById(`${prefix}masscanPortsScan`);
    const portSelector = document.getElementById(`${prefix}masscanPortsSelector`);
    
    if (!portSwitch || !portSelector) return;

    const updatePlaceholders = (isEnabled) => {
      const portValue = portSelector.value.trim();
      const newPlaceholder = isEnabled && portValue ? portValue : '--ping';
      
      const portInputs = document.querySelectorAll(
        `#${instance.modalId}_body .form-control.port`
      );
      portInputs.forEach(input => {
        input.placeholder = newPlaceholder;
      });
    };

    FormHelpers.linkSwitchToInput(portSwitch, portSelector, updatePlaceholders);
    
    portSelector.addEventListener('input', () => {
      if (portSwitch.checked) {
        updatePlaceholders(true);
      }
    });
  },

  setupSourcePortSwitch(prefix) {
    const sourcePortSwitch = document.getElementById(`${prefix}sourcePortScan`);
    const sourcePortSelector = document.getElementById(`${prefix}masscanSourcePortSelector`);
    
    if (sourcePortSwitch && sourcePortSelector) {
      FormHelpers.linkSwitchToInput(sourcePortSwitch, sourcePortSelector);
    }
  },

  setupMaxRateSwitch(prefix) {
    const maxRateSwitch = document.getElementById(`${prefix}maxRate`);
    const maxRateSelector = document.getElementById(`${prefix}masscanMaxRateSelector`);
    
    if (maxRateSwitch && maxRateSelector) {
      FormHelpers.linkSwitchToInput(maxRateSwitch, maxRateSelector);
    }
  },

  setupWaitSlider(prefix) {
    const waitSlider = document.getElementById(`${prefix}masscanWaitRange`);
    const waitValue = document.getElementById(`${prefix}waitValue`);
    
    if (waitSlider && waitValue) {
      waitSlider.addEventListener('input', (e) => {
        waitValue.textContent = e.target.value;
      });
    }
  },

  resetAll(prefix) {
    const portSwitch = document.getElementById(`${prefix}masscanPortsScan`);
    const portSelector = document.getElementById(`${prefix}masscanPortsSelector`);
    if (portSwitch && portSelector) {
      portSwitch.checked = false;
      portSelector.value = '';
      portSelector.disabled = true;
    }
    
    const sourcePortSwitch = document.getElementById(`${prefix}sourcePortScan`);
    const sourcePortSelector = document.getElementById(`${prefix}masscanSourcePortSelector`);
    if (sourcePortSwitch && sourcePortSelector) {
      sourcePortSwitch.checked = false;
      sourcePortSelector.value = '';
      sourcePortSelector.disabled = true;
    }
    
    const maxRateSwitch = document.getElementById(`${prefix}maxRate`);
    const maxRateSelector = document.getElementById(`${prefix}masscanMaxRateSelector`);
    if (maxRateSwitch && maxRateSelector) {
      maxRateSwitch.checked = false;
      maxRateSelector.value = '';
      maxRateSelector.disabled = true;
    }
  }
};

const MasscanHandlers = {

  async handleNodeModal(instance, node) {
    const prefix = instance.prefix;
    
    instance.reset();
    
    const ipInput = document.getElementById(`${prefix}inputIP`);
    if (ipInput) {
      ipInput.value = node.label || node.name || node.ip || node.domain || node.id || '';
    }

    if (node.id && node.id !== 'undefined') {
      try {
        const response = await fetch(`/api/v1/vis/node_info/${node.id}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        const portInput = document.getElementById(`${prefix}inputPort`);
        
        if (data.ports && portInput) {
          const ports = [...new Set(data.ports.map(p => p.port))].join(',');
          portInput.value = ports || '--ping';
        }
      } catch (error) {
        console.error('Failed to load node ports:', error);
        const portInput = document.getElementById(`${prefix}inputPort`);
        if (portInput) {
          portInput.value = '--ping';
        }
      }
    } else {
      const portInput = document.getElementById(`${prefix}inputPort`);
      if (portInput) {
        portInput.value = '--ping';
      }
    }
    
    window[`show_${instance.modalId}`]();
  },

  async handleLogParsing(instance) {
    const agentId = window.agentData?.default_agent;
    const iface = window.interfaceData?.default_interface;

    if (!agentId) {
      return create_toast('Info', 'Please select an Agent', 'info');
    }
    if (!iface) {
      return create_toast('Info', 'Please select an Interface', 'info');
    }

    try {
      const files = await FormHelpers.selectAndReadFiles('.txt,.xml,.json,.list', true);
      
      for (const { content, filename } of files) {
        const payload = {
          file: content,
          filename: filename,
          agent_id: String(agentId),
          interface_ip_id: String(iface.ip_id || iface.id),
          ip: String(iface.ip || ""),
          mac: String(iface.mac || "")
        };

        await fetch('/api/v1/task/masscan_parse_task', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
      }
      
      window[`close_${instance.modalId}`]();
    } catch (error) {
      console.error('Failed to parse Masscan logs:', error);
      create_toast('Error', 'Error reading or uploading files', 'error');
    }
  },

  handlePrefill(instance, rows = [], prefillParams = {}) {
    const prefix = instance.prefix;
    
    instance.reset();

    const targetTab = document.getElementById(`${prefix}target-tab`);
    if (targetTab) {
      const tab = new bootstrap.Tab(targetTab);
      tab.show();
    }
    
    if (rows.length === 0 && prefillParams.target) {
      const ipInput = document.getElementById(`${prefix}inputIP`);
      const portInput = document.getElementById(`${prefix}inputPort`);
      
      if (ipInput) ipInput.value = prefillParams.target;
      if (portInput) {
        portInput.value = prefillParams.ports ? prefillParams.ports : '--ping';
      }
    }

    if (rows.length > 0) {
      const ipMap = new Map();
      
      rows.forEach(row => {
        const ip = (row.ipaddr || '').trim();
        const port = String(row.port || '').trim();
        
        if (!ip) return;
        
        const existing = ipMap.get(ip) || '';
        const combined = existing ? `${existing},${port}` : port;
        const uniquePorts = [...new Set(combined.split(',').filter(Boolean))].join(',');
        
        ipMap.set(ip, uniquePorts);
      });

      Array.from(ipMap.entries()).forEach(([ip, ports], index) => {
        if (index === 0) {
          const ipInput = document.getElementById(`${prefix}inputIP`);
          const portInput = document.getElementById(`${prefix}inputPort`);
          
          if (ipInput) ipInput.value = ip;
          if (portInput) portInput.value = ports;
        } else {
          instance.addInputField('ip_port');
          
          const container = document.getElementById(`${prefix}InputContainer`);
          const lastGroup = container?.lastElementChild;
          
          if (lastGroup) {
            const ipInput = lastGroup.querySelector('.ip');
            const portInput = lastGroup.querySelector('.port');
            
            if (ipInput) ipInput.value = ip;
            if (portInput) portInput.value = ports;
          }
        }
      });
    }

    if (Object.keys(prefillParams).length > 0) {
      this.applyPrefillParams(prefix, prefillParams);
    }

    window[`show_${instance.modalId}`]();
  },

  applyPrefillParams(prefix, params) {
    if (params.protocol) {
      const protocolRadio = document.getElementById(
        `${prefix}protocol${params.protocol.charAt(0).toUpperCase() + params.protocol.slice(1)}`
      );
      if (protocolRadio) {
        protocolRadio.checked = true;
      }
    }

    if (params.format) {
      const formatRadio = document.getElementById(`${prefix}${params.format.toLowerCase()}`);
      if (formatRadio) {
        formatRadio.checked = true;
      }
    }
    /*if (params.ports != null && params.ports !== '' && params.ports !== 'null') {
      const portSwitch = document.getElementById(`${prefix}masscanPortsScan`);
      const portSelector = document.getElementById(`${prefix}masscanPortsSelector`);
      
      if (portSwitch && portSelector) {
        portSelector.value = String(params.ports);
        portSwitch.checked = true;
        portSelector.disabled = false;
      }
    }*/

    if (params.wait !== null && params.wait !== '' && params.wait !== 'null') {
      const waitSlider = document.getElementById(`${prefix}masscanWaitRange`);
      if (waitSlider) {
        const waitVal = Math.max(0, Math.min(20, parseInt(params.wait, 10) || 10));
        waitSlider.value = waitVal;
        const waitValue = document.getElementById(`${prefix}waitValue`);
        if (waitValue) {
          waitValue.textContent = waitVal;
        }
      }
    }

    if (params.source_port !== null && params.source_port !== '' && params.source_port !== 'null') {
      const srcPortSwitch = document.getElementById(`${prefix}sourcePortScan`);
      const srcPortSelector = document.getElementById(`${prefix}masscanSourcePortSelector`);
      
      if (srcPortSwitch && srcPortSelector) {
        srcPortSelector.value = String(params.source_port);
        srcPortSwitch.checked = true;
        srcPortSelector.disabled = false;
      }
    }

    if (params.max_rate !== null && params.max_rate !== '' && params.max_rate !== 'null') {
      const maxRateSwitch = document.getElementById(`${prefix}maxRate`);
      const maxRateSelector = document.getElementById(`${prefix}masscanMaxRateSelector`);
      
      if (maxRateSwitch && maxRateSelector) {
        maxRateSelector.value = String(params.max_rate);
        maxRateSwitch.checked = true;
        maxRateSelector.disabled = false;
      }
    }
  },

  // Получение конфигурации таблицы базы данных
  getDatabaseTableConfig() {
    return {
      columns: [
        { 
          title: "Select", 
          field: "selected", 
          formatter: "rowSelection", 
          titleFormatter: "rowSelection", 
          hozAlign: "center", 
          headerHozAlign: "center", 
          headerSort: false,
          width: 50
        },
        { 
          title: "IP Address", 
          field: "ipaddr", 
          headerFilter: "input", 
          headerFilterPlaceholder: "Search IP..." 
        },
        { 
          title: "Port", 
          field: "port", 
          headerFilter: "input", 
          headerFilterPlaceholder: "Search port..." 
        }
      ],
      filter: [
        { field: "ipaddr", type: "!=", value: "" }
      ]
    };
  }
};

class MasscanScanner {
  constructor(prefix) {
    this.prefix = prefix;
  }

  getBaseParams() {
    const agentId = window.agentData?.default_agent;
    const ifaceObj = window.interfaceData?.default_interface;

    if (!agentId) {
      throw new Error("Please select an Agent");
    }
    if (!ifaceObj) {
      throw new Error("Please select an Interface");
    }

    const params = {
      interface_ip_id: String(ifaceObj.ip_id || ifaceObj.id),
      interface: String(ifaceObj.name),
      agent_id: String(agentId),
      search_udp_port: document.querySelector(`input[name="${this.prefix}protocol"]:checked`)?.value === 'udp',
      format: document.querySelector(`input[name="${this.prefix}format"]:checked`)?.value || 'oJ',
      wait: document.getElementById(`${this.prefix}masscanWaitRange`)?.value || '10',
      source_port: null,
      max_rate: null,
      ports: null,
      ping: true,
      scope_id: ""
    };

    const portSwitch = document.getElementById(`${this.prefix}masscanPortsScan`);
    if (portSwitch?.checked) {
      const portValue = document.getElementById(`${this.prefix}masscanPortsSelector`)?.value?.trim();
      if (portValue) {
        params.ports = portValue;
        params.ping = false;
      }
    }

    const sourcePortSwitch = document.getElementById(`${this.prefix}sourcePortScan`);
    if (sourcePortSwitch?.checked) {
      const sourcePortValue = document.getElementById(`${this.prefix}masscanSourcePortSelector`)?.value?.trim();
      if (sourcePortValue) {
        params.source_port = sourcePortValue;
      }
    }

    const maxRateSwitch = document.getElementById(`${this.prefix}maxRate`);
    if (maxRateSwitch?.checked) {
      const maxRateValue = document.getElementById(`${this.prefix}masscanMaxRateSelector`)?.value?.trim();
      if (maxRateValue) {
        params.max_rate = maxRateValue;
      }
    }

    return params;
  }

  async scanScope(scopeId) {
    const baseParams = this.getBaseParams();
    const payload = { ...baseParams, scope_id: String(scopeId) };

    const result = await window.executeToolTasks({
      tasks: [{ endpoint: '/api/v1/task/masscan_scan_task', payload }],
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Scan failed');
    }

    return result.responses[0];
  }

  async scanTargets(targets) {
    const baseParams = this.getBaseParams();
    const tasks = [];

    for (const target of targets) {
      const payload = { ...baseParams };
      const ip = String(target.ip || target.domain || target.url || target);
      
      if (target.port && target.port.trim()) {
        const portsArray = target.port.split(',')
          .map(p => p.trim())
          .filter(p => p && p !== 'null' && p !== 'undefined' && p !== '');
        
        if (portsArray.length > 0) {
          payload.ports = portsArray.join(',');
          payload.ping = false;
          payload.target = ip;
        } else {
          payload.target = ip;
          payload.ping = true;
        }
      } else {
        payload.target = ip;
        payload.ping = true;
      }

      tasks.push({ endpoint: '/api/v1/task/masscan_scan_task', payload });
    }

    const result = await window.executeToolTasks({
      tasks,
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Scan failed');
    }

    return result.responses;
  }
}

ToolModalBuilder.register('masscanModalWindow', {
  prefix: 'masscan_',
  
  tabs: [
    { id: 'target', label: i18next.t('Target'), targetType: 'ip_port' },
    { id: 'scope', label: i18next.t('Scope') },
    { id: 'database', label: i18next.t('Database') },
    //{ id: 'textarea', label: i18next.t('Textarea'), placeholder: '192.168.1.1:80, 10.0.0.0/24' },
  ],
  
  toolParams: (prefix) => MasscanUI.buildParams(prefix),

  // Добавляем метод для получения конфигурации таблицы базы данных
  getDatabaseTableConfig() {
    return MasscanHandlers.getDatabaseTableConfig();
  },

  onInit(instance) {
    const prefix = instance.prefix;

    MasscanSwitches.setupAll(prefix, instance);

    const parseBtn = document.getElementById(`${prefix}parseLogsBtn`);
    if (parseBtn) {
      parseBtn.addEventListener('click', () => {
        MasscanHandlers.handleLogParsing(instance);
      });
    }

    // Инициализация таблицы базы данных при переключении на вкладку database
    const dbTabTrigger = document.getElementById(`${prefix}database-tab`);
    if (dbTabTrigger) {
      let tableInitialized = false;
      
      dbTabTrigger.addEventListener('shown.bs.tab', () => {
        if (!tableInitialized) {
          // Используем метод initDatabaseTable из экземпляра
          instance.initDatabaseTable();
          tableInitialized = true;
          
          // Настраиваем обработчик выбора строк в таблице
          setTimeout(() => {
            if (instance.databaseTable) {
              const originalRowSelectionChanged = instance.databaseTable.options.rowSelectionChanged;
              
              instance.databaseTable.options.rowSelectionChanged = function(data, rows) {
                const ipMap = new Map();
                
                rows.forEach((row) => {
                  const rowData = row.getData();
                  const ip = rowData.ipaddr;
                  const port = rowData.port;
                  const domain = rowData.domain;
                  
                  if (!ip) return;
                  
                  if (ipMap.has(ip)) {
                    const existing = ipMap.get(ip);
                    if (port && port !== 'null' && port !== 'undefined' && port !== '') {
                      existing.ports.add(port.toString());
                    }
                  } else {
                    const portsSet = new Set();
                    if (port && port !== 'null' && port !== 'undefined' && port !== '') {
                      portsSet.add(port.toString());
                    }
                    ipMap.set(ip, {
                      ip: ip,
                      domain: domain || '',
                      ports: portsSet
                    });
                  }
                });
                
                instance.state.selectedDatabaseTargets = {};
                ipMap.forEach((value, key) => {
                  instance.state.selectedDatabaseTargets[key] = value;
                });
              };
            }
          }, 100);
        }
      });
    }

    window.masscan_script_modal_to_node = (node) => {
      MasscanHandlers.handleNodeModal(instance, node);
    };

    window.masscan_start_with_prefill = (rows = [], prefillParams = {}) => {
      MasscanHandlers.handlePrefill(instance, rows, prefillParams);
    };
  },

  onReset(instance) {
    const prefix = instance.prefix;

    MasscanSwitches.resetAll(prefix);

    const tcpRadio = document.getElementById(`${prefix}protocolTcp`);
    if (tcpRadio) {
      tcpRadio.checked = true;
    }

    const jsonFormat = document.getElementById(`${prefix}oj`);
    if (jsonFormat) {
      jsonFormat.checked = true;
    }

    const waitSlider = document.getElementById(`${prefix}masscanWaitRange`);
    if (waitSlider) {
      waitSlider.value = '10';
      const waitValue = document.getElementById(`${prefix}waitValue`);
      if (waitValue) {
        waitValue.textContent = '10';
      }
    }

    const portInputs = document.querySelectorAll(`#${instance.modalId}_body .form-control.port`);
    portInputs.forEach(input => {
      input.placeholder = '--ping';
    });

    // Сбрасываем выбранные цели из базы данных
    instance.state.selectedDatabaseTargets = {};
  },

  async onStart(instance) {
    const scanner = new MasscanScanner(instance.prefix);
    
    try {
      const tabId = instance.getActiveTab();
      let result;

      if (tabId === 'scope') {
        if (!instance.state.selectedScopeId) {
          return create_toast('Warning', 'Select scope', 'warning');
        }
        result = await scanner.scanScope(instance.state.selectedScopeId);
      } else if (tabId === 'database') {
        // Обработка целей из базы данных
        const targets = [];
        
        Object.values(instance.state.selectedDatabaseTargets || {}).forEach(item => {
          const portsArray = Array.from(item.ports || [])
            .filter(p => p && p !== 'null' && p !== 'undefined' && p !== '');
          
          targets.push({
            ip: item.ip,
            domain: item.domain || '',
            port: portsArray.join(','),
            target: item.ip
          });
        });
        
        if (!targets.length) {
          return create_toast('Warning', 'No targets selected from database', 'warning');
        }
        result = await scanner.scanTargets(targets);
      } else {
        const targets = instance.getTargets();
        
        if (!targets.length) {
          return create_toast('Warning', 'No targets found', 'warning');
        }
        result = await scanner.scanTargets(targets);
      }

      if (result !== null) {
        window[`close_${instance.modalId}`]();
      }
    } catch (error) {
      console.error('Failed to start Masscan scan:', error);
      create_toast('Warning', 'Failed to start scan', 'warning');
    }
  }
});
</script>