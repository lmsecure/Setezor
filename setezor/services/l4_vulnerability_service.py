import os
import aiofiles
from fastapi import HTTPException
from setezor.services.base_service import BaseService
from setezor.models.l4_software_vulnerability_screenshot import L4SoftwareVulnerabilityScreenshot
from setezor.settings import PROJECTS_DIR_PATH
import base64
from uuid import uuid4


class L4VulnerabilityService(BaseService):
    async def set_status(self, id:int, status: str, project_id: str) -> list[dict]:
        async with self._uow:
            vuln_obj = await self._uow.l4_software_vulnerability.find_one(id=id, project_id=project_id)
        if not vuln_obj:
            raise HTTPException(status_code=403, detail="You can't edit this vulnerability")
        async with self._uow:
            await self._uow.l4_software_vulnerability.edit_one(id=id, data={"confirmed":status})
            await self._uow.commit()
        return status


    async def get_screenshots(self, project_id: str, scan_id: str, vuln_id: str) -> list[dict]:
        async with self._uow:
            screenshot_objs = [obj for obj in await self._uow.l4_software_vulnerability_screenshot.filter(project_id=project_id, scan_id=scan_id, l4_software_vulnerability_id=vuln_id) if not obj.deleted_at]
        result = []
        for screenshot in screenshot_objs:
            result.append({
                "id" : screenshot.id,
                "note" : screenshot.note })
        return result


    async def add_screenshot(self, project_id: str, scan_id: str, vuln_id: str, data: dict) -> int:
        screenshots_path = os.path.join(PROJECTS_DIR_PATH, project_id, scan_id, "screenshots")
        if not os.path.exists(screenshots_path):
            os.makedirs(screenshots_path, exist_ok=True)
        screenshot_data = base64.b64decode(data.get("file").split(",")[1])
        if len(screenshot_data) < 12:
            raise HTTPException(
                status_code=400,
                detail="Incorrect file"
            )
        if len(screenshot_data) > 5242880:
            raise HTTPException(
                status_code=413,
                detail="The file size limit has been exceeded"
            )
        if not (any([screenshot_data.startswith(mb) for mb in [b"\x89PNG", b"BM", b"\xFF\xD8\xFF"]]) or screenshot_data.startswith(b"RIFF") and screenshot_data[8:12] == b"WEBP"):
            raise HTTPException(
                status_code=415,
                detail="Incorrect file format"
            )
        screenshot_id = uuid4().hex
        file_path = os.path.join(screenshots_path, screenshot_id)
        async with aiofiles.open(file_path, 'wb') as file:
            await file.write(screenshot_data)
        async with self._uow:
            new_obj = L4SoftwareVulnerabilityScreenshot(project_id=project_id,
                                                        scan_id=scan_id,
                                                        l4_software_vulnerability_id=vuln_id,
                                                        note=data.get("note"),
                                                        screenshot_id=screenshot_id)
            self._uow.l4_software_vulnerability_screenshot.add(data=new_obj.model_dump())
            await self._uow.commit()
            screenshot_objs = [obj for obj in await self._uow.l4_software_vulnerability_screenshot.filter(project_id=project_id, scan_id=scan_id, l4_software_vulnerability_id=vuln_id) if not obj.deleted_at]

        return len(screenshot_objs)


    async def delete_screenshot(self, project_id: str, scan_id: str, id: str) -> int:
        async with self._uow:
            delete_obj = await self._uow.l4_software_vulnerability_screenshot.find_one(project_id=project_id, scan_id=scan_id, id=id)
            await self._uow.l4_software_vulnerability_screenshot.delete(id=id)
            await self._uow.commit()
            screenshot_objs = [obj for obj in await self._uow.l4_software_vulnerability_screenshot.filter(project_id=project_id, scan_id=scan_id, l4_software_vulnerability_id=delete_obj.l4_software_vulnerability_id) if not obj.deleted_at]
        return len(screenshot_objs)


    async def get_screenshot(self, project_id: str, scan_id: str, id: str) -> bytes:
        async with self._uow:
            l4_software_vulnerability_screenshot = await self._uow.l4_software_vulnerability_screenshot.find_one(project_id=project_id, scan_id=scan_id, id=id)
        if not l4_software_vulnerability_screenshot:
            raise FileNotFoundError(f"Screenshot file not found for vulnerability ID: {id}")
        screenshot_id = l4_software_vulnerability_screenshot.screenshot_id
        file_path = os.path.join(PROJECTS_DIR_PATH, project_id, scan_id, "screenshots", screenshot_id)
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Screenshot file not found for ID: {screenshot_id}")
        with open(file_path, "rb") as f:
            return f.read()