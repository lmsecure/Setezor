{% import 'modals/tools_modal_constructor.html' as modal %}

{{ modal.create_modal('nmapModalWindow', 'Nmap', 'https://help.setezor.net/nmap') }}

<script>
const NmapDescriptions = {
  scanTechniques: {
    '-sS': 'TCP SYN scan',
    '-sT': 'TCP Connect() scan',
    '-sA': 'TCP ACK scan',
    '-sW': 'TCP Window scan',
    '-sM': 'TCP Maimon scan',
    '-sU': 'UDP Scan',
    '-sP': 'Ping Scan'
  },
  
  discovery: {
    '-PA': 'TCP ACK discovery to given ports',
    '-PS': 'TCP SYN discovery to given ports',
    '-PU': 'UDP discovery to given ports',
    '-PY': 'SCTP discovery to given ports'
  },
  
  icmp: {
    '-PE': 'ICMP echo request discovery probes',
    '-PP': 'ICMP timestamp request discovery probes',
    '-PM': 'ICMP netmask request discovery probes'
  }
};

const NmapUI = {

  getStyles() {
    return `
      <style>
        .nmap-tool-section {
          background: #f8f9fa;
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 15px;
          border: 1px solid #e9ecef;
        }
        .nmap-tool-section h6 {
          font-size: 0.85rem;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: #6c757d;
          margin-bottom: 10px;
          font-weight: bold;
          display: flex;
          align-items: center;
        }
        .nmap-tool-section h6 i { 
          margin-right: 8px; 
        }
      </style>
    `;
  },

  createRadioGroup(prefix, name, values, descriptions) {
    return values.map(v => `
      <input type="radio" class="btn-check" 
             name="${prefix}${name}" 
             value="${v}" 
             id="${prefix}${v.replace('-','')}" 
             autocomplete="off">
      <label class="btn btn-outline-primary" 
             for="${prefix}${v.replace('-','')}" 
             title="${descriptions[v]}" 
             data-bs-toggle="tooltip">
        ${v.replace('-','')}
      </label>
    `).join('');
  },

  buildParams(prefix) {
    return `
      ${this.getStyles()}
      ${this.buildGeneralOptions(prefix)}
      ${this.buildScanTechniques(prefix)}
      ${this.buildDiscoveryOptions(prefix)}
      ${this.buildParseButton(prefix)}
    `;
  },

  buildGeneralOptions(prefix) {
    return `
      <div class="nmap-tool-section">
        <h6><i class="bi bi-gear-fill"></i> ${i18next.t("General Options & Ports")}</h6>
        
        <div class="row g-3 align-items-center">
          <div class="col-6">
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="${prefix}portsScan">
              <label class="form-check-label" for="${prefix}portsScan">
                ${i18next.t("Ports")}
              </label>
            </div>
          </div>
          <div class="col-6">
            <input type="text" 
                   list="${prefix}portsSelectorList" 
                   id="${prefix}portsSelector" 
                   class="form-control" 
                   placeholder="${i18next.t("Ports")}" 
                   disabled>
            <datalist id="${prefix}portsSelectorList">
              <option value="--top-ports 1000">${i18next.t("top-1000")}</option>
              <option value="--top-ports 100">${i18next.t("top-100")}</option>
              <option value="-p 80,443,8080,8443">${i18next.t("web ports")}</option>
              <option value="-p-">${i18next.t("All")}</option>
            </datalist>
          </div>
        </div>

        <div class="row mt-2">
          <div class="col-6">
            <div class="form-check form-switch" 
                 title="${i18next.t("Trace hop path to each host")}" 
                 data-bs-toggle="tooltip">
              <input class="form-check-input" type="checkbox" id="${prefix}trace" checked>
              <label class="form-check-label" for="${prefix}trace">
                ${i18next.t("TraceRoute")}
              </label>
            </div>
          </div>
          <div class="col-6">
            <div class="form-check form-switch" 
                 title="${i18next.t("Attempts to determine the version of the service running on port")}" 
                 data-bs-toggle="tooltip">
              <input class="form-check-input" type="checkbox" id="${prefix}service">
              <label class="form-check-label" for="${prefix}service">
                ${i18next.t("Service Version")}
              </label>
            </div>
          </div>
          <div class="col-6">
            <div class="form-check form-switch" 
                 title="${i18next.t("OS detection")}" 
                 data-bs-toggle="tooltip">
              <input class="form-check-input" type="checkbox" id="${prefix}stealth">
              <label class="form-check-label" for="${prefix}stealth">
                ${i18next.t("OS detection")}
              </label>
            </div>
          </div>
          <div class="col-6">
            <div class="form-check form-switch" 
                 title="${i18next.t("Disable host discovery. Port scan only.")}" 
                 data-bs-toggle="tooltip">
              <input class="form-check-input" type="checkbox" id="${prefix}pn">
              <label class="form-check-label" for="${prefix}pn">
                ${i18next.t("Skip discovery")}
              </label>
            </div>
          </div>
        </div>
      </div>
    `;
  },

  buildScanTechniques(prefix) {
    const techniques = ['-sS','-sT','-sA','-sW','-sM','-sU','-sP'];
    return `
      <div class="nmap-tool-section">
        <h6><i class="bi bi-search"></i> ${i18next.t("Scan Techniques")}</h6>
        <div class="btn-group w-100" role="group">
          ${this.createRadioGroup(prefix, 'scanTechniques', techniques, NmapDescriptions.scanTechniques)}
        </div>
      </div>
    `;
  },

  buildDiscoveryOptions(prefix) {
    const tcpUdp = ['-PA','-PS','-PU','-PY'];
    const icmp = ['-PE','-PP','-PM'];
    
    return `
      <div class="row g-2">
        <div class="col-md-7">
          <div class="nmap-tool-section h-100">
            <h6><i class="bi bi-broadcast"></i> ${i18next.t("TCP/UDP discovery")}</h6>
            <div class="btn-group w-100" role="group">
              ${this.createRadioGroup(prefix, 'portsDiscovery', tcpUdp, NmapDescriptions.discovery)}
            </div>
          </div>
        </div>
        <div class="col-md-5">
          <div class="nmap-tool-section h-100">
            <h6><i class="bi bi-shield-check"></i> ${i18next.t("ICMP request discovery")}</h6>
            <div class="btn-group w-100" role="group">
              ${this.createRadioGroup(prefix, 'requestDiscovery', icmp, NmapDescriptions.icmp)}
            </div>
          </div>
        </div>
      </div>
    `;
  },

  buildParseButton(prefix) {
    return `
      <button class="btn btn-primary w-100 mt-3 shadow-sm" id="${prefix}parseXmlBtn">
        <i class="bi bi-file-earmark-code me-2"></i>${i18next.t("Parse xml logs")}
      </button>
    `;
  }
};

const NmapHandlers = {

  setupPortSwitch(prefix) {
    const portSwitch = document.getElementById(`${prefix}portsScan`);
    const portInput = document.getElementById(`${prefix}portsSelector`);
    
    if (portSwitch && portInput) {
      FormHelpers.linkSwitchToInput(portSwitch, portInput);
    }
  },

  setupToggleableRadios(prefix) {
    const radios = document.querySelectorAll(`input[type="radio"][id^="${prefix}"]`);
    FormHelpers.makeRadiosToggleable(radios);
  },

  async handleXmlParsing(instance) {
    const agentId = window.agentData?.default_agent;
    const iface = window.interfaceData?.default_interface;

    if (!agentId || !iface) {
      return;
    }

    try {
      const files = await FormHelpers.selectAndReadFiles('.xml', true);
      
      for (const { content, filename } of files) {
        const payload = {
          file: content,
          filename: filename,
          agent_id: String(agentId),
          interface_ip_id: String(iface.ip_id || iface.id),
          ip: String(iface.ip || ""),
          mac: String(iface.mac || "")
        };

        await fetch('/api/v1/task/nmap_parse_task', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
      }
      
      window[`close_${instance.modalId}`]();
    } catch (error) {
      console.error('Failed to parse XML files:', error);
    }
  },

  async handleNodeModal(instance, node) {
    const prefix = instance.prefix;
    
    instance.reset();
    
    const ipInput = document.getElementById(`${prefix}inputIP`);
    if (ipInput) {
      ipInput.value = node.label || '';
    }

    try {
      const response = await fetch(`/api/v1/vis/node_info/${node.id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      const portInput = document.getElementById(`${prefix}inputPort`);
      
      if (data.ports && portInput) {
        const ports = [...new Set(data.ports.map(p => p.port))].join(',');
        portInput.value = ports;
      }
    } catch (error) {
      console.error('Failed to load node ports:', error);
    }
    
    window[`show_${instance.modalId}`]();
  },

  handlePrefill(instance, rows = [], params = {}) {
    const prefix = instance.prefix;
    
    instance.reset();
    
    const targetTab = document.getElementById(`${prefix}target-tab`);
    if (targetTab) {
      const tab = new bootstrap.Tab(targetTab);
      tab.show();
    }
    
    if (params.targetPorts) {
      const portSwitch = document.getElementById(`${prefix}portsScan`);
      const portInput = document.getElementById(`${prefix}portsSelector`);
      
      if (portSwitch && portInput) {
        portSwitch.checked = true;
        portInput.disabled = false;
        
        let cleanValue = params.targetPorts.trim();
        if (cleanValue.startsWith('-p ')) cleanValue = cleanValue.slice(3);
        else if (cleanValue.startsWith('-p')) cleanValue = cleanValue.slice(2);
        
        portInput.value = cleanValue;
      }
    }

    const ipMap = new Map();
    rows.forEach(row => {
      const ip = (row.ipaddr || '').trim();
      const port = String(row.port || '').trim();
      
      if (!ip) return;
      
      const existing = ipMap.get(ip) || '';
      const combined = existing ? `${existing},${port}` : port;
      const uniquePorts = [...new Set(combined.split(',').filter(Boolean))].join(',');
      
      ipMap.set(ip, uniquePorts);
    });

    Array.from(ipMap.entries()).forEach(([ip, ports], index) => {
      if (index === 0) {
        const ipInput = document.getElementById(`${prefix}inputIP`);
        const portInput = document.getElementById(`${prefix}inputPort`);
        
        if (ipInput) ipInput.value = ip;
        if (portInput) portInput.value = ports;
      } else {
        instance.addInputField('ip_port');
        
        const container = document.getElementById(`${prefix}InputContainer`);
        const lastGroup = container?.lastElementChild;
        
        if (lastGroup) {
          const ipInput = lastGroup.querySelector('.ip');
          const portInput = lastGroup.querySelector('.port');
          
          if (ipInput) ipInput.value = ip;
          if (portInput) portInput.value = ports;
        }
      }
    });
    
    window[`show_${instance.modalId}`]();
  }
};

class NmapScanner {
  constructor(prefix) {
    this.prefix = prefix;
  }

  getRadioValue(name) {
    const radio = document.querySelector(`input[name="${this.prefix}${name}"]:checked`);
    return radio?.value || "";
  }

  getGlobalPorts() {
    const portSwitch = document.getElementById(`${this.prefix}portsScan`);
    if (!portSwitch?.checked) return "";
    
    const portValue = document.getElementById(`${this.prefix}portsSelector`)?.value;
    if (!portValue) return "";
    
    return portValue.startsWith('-') ? portValue : `-p ${portValue}`;
  }

  getBaseParams() {
    const agentId = window.agentData?.default_agent;
    const ifaceObj = window.interfaceData?.default_interface;

    if (!agentId) {
      throw new Error("Please select an Agent");
    }
    if (!ifaceObj) {
      throw new Error("Please select an Interface");
    }

    return {
      agent_id: String(agentId),
      interface: String(ifaceObj.name),
      interface_ip_id: String(ifaceObj.ip_id || ifaceObj.id),
      traceroute: !!document.getElementById(`${this.prefix}trace`)?.checked,
      serviceVersion: !!document.getElementById(`${this.prefix}service`)?.checked,
      stealthScan: !!document.getElementById(`${this.prefix}stealth`)?.checked,
      skipDiscovery: !!document.getElementById(`${this.prefix}pn`)?.checked,
      scanTechniques: this.getRadioValue('scanTechniques'),
      portsDiscovery: this.getRadioValue('portsDiscovery'),
      requestDiscovery: this.getRadioValue('requestDiscovery'),
      targetPorts: "",
      targetIP: null,
      scope_id: ""
    };
  }

  async scanScope(scopeId) {
    const baseParams = this.getBaseParams();
    const globalPorts = this.getGlobalPorts();
    
    const payload = { 
      ...baseParams, 
      scope_id: String(scopeId),
      targetPorts: globalPorts
    };

    const result = await window.executeToolTasks({
      tasks: [{ endpoint: '/api/v1/task/nmap_scan_task', payload }],
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Scan failed');
    }
    return result.responses[0];
  }

  async scanTargets(targets) {
    const baseParams = this.getBaseParams();
    const globalPorts = this.getGlobalPorts();
    const tasks = [];

    for (const target of targets) {
      const payload = { ...baseParams };
      payload.targetIP = String(target.ip || target.domain || target.url || target.target || target);
      
      const targetPort = target.port ? String(target.port).trim() : '';
      const hasValidPort = targetPort && targetPort !== 'null' && targetPort !== 'undefined' && targetPort !== '';
      
      if (hasValidPort) {
        const portsArray = targetPort.split(',')
          .map(p => p.trim())
          .filter(p => p && p !== 'null' && p !== 'undefined' && p !== '');
        
        if (portsArray.length > 0) {
          payload.targetPorts = `-p ${portsArray.join(',')}`;
        } else {
          payload.targetPorts = globalPorts;
        }
      } else {
        payload.targetPorts = globalPorts;
      }

      tasks.push({ endpoint: '/api/v1/task/nmap_scan_task', payload });
    }

    const result = await window.executeToolTasks({
      tasks,
      stopOnFirstFailure: true
    });

    if (!result.success) {
      if (result.reason === 'module_install_requested') {
        return null;
      }
      throw new Error(result.error?.message || 'Scan failed');
    }

    return result.responses;
  }
}

ToolModalBuilder.register('nmapModalWindow', {
  prefix: 'nmap_',
  
  tabs: [
    { id: 'target', label: i18next.t('Target'), targetType: 'ip_port' },
    { id: 'scope', label: i18next.t('Scope') },
    { id: 'database', label: i18next.t('Database') },
    //{ id: 'textarea', label: i18next.t('Textarea'), placeholder: '192.168.1.1:80' },
  ],
  
  toolParams: (prefix) => NmapUI.buildParams(prefix),

  getDatabaseTableConfig() {
    return {
      columns: [
        { 
          title: "Select", 
          field: "selected", 
          formatter: "rowSelection", 
          titleFormatter: "rowSelection", 
          hozAlign: "center", 
          headerHozAlign: "center", 
          headerSort: false,
          width: 50
        },
        { 
          title: "IP Address", 
          field: "ipaddr", 
          headerFilter: "input", 
          headerFilterPlaceholder: "Search IP..." 
        },
        { 
          title: "Port", 
          field: "port", 
          headerFilter: "input", 
          headerFilterPlaceholder: "Search port..." 
        }
      ],
      filter: [
        { field: "ipaddr", type: "!=", value: "" }
      ]
    };
  },

  onInit(instance) {
    const prefix = instance.prefix;
    NmapHandlers.setupPortSwitch(prefix);
    NmapHandlers.setupToggleableRadios(prefix);
    
    const parseBtn = document.getElementById(`${prefix}parseXmlBtn`);
    if (parseBtn) {
      parseBtn.addEventListener('click', () => {
        NmapHandlers.handleXmlParsing(instance);
      });
    }

    const dbTabTrigger = document.getElementById(`${prefix}database-tab`);
    if (dbTabTrigger) {
      let tableInitialized = false;
      
      dbTabTrigger.addEventListener('shown.bs.tab', () => {
        if (!tableInitialized) {
          instance.initDatabaseTable();
          tableInitialized = true;
          
          setTimeout(() => {
            if (instance.databaseTable) {
              const originalRowSelectionChanged = instance.databaseTable.options.rowSelectionChanged;
              
              instance.databaseTable.options.rowSelectionChanged = function(data, rows) {
                const ipMap = new Map();
                
                rows.forEach((row) => {
                  const rowData = row.getData();
                  const ip = rowData.ipaddr;
                  const port = rowData.port;
                  const domain = rowData.domain;
                  
                  if (!ip) return;
                  
                  if (ipMap.has(ip)) {
                    const existing = ipMap.get(ip);
                    if (port && port !== 'null' && port !== 'undefined' && port !== '') {
                      existing.ports.add(port.toString());
                    }
                  } else {
                    const portsSet = new Set();
                    if (port && port !== 'null' && port !== 'undefined' && port !== '') {
                      portsSet.add(port.toString());
                    }
                    ipMap.set(ip, {
                      ip: ip,
                      domain: domain || '',
                      ports: portsSet
                    });
                  }
                });
                
                instance.state.selectedDatabaseTargets = {};
                ipMap.forEach((value, key) => {
                  instance.state.selectedDatabaseTargets[key] = value;
                });
              };
            }
          }, 100);
        }
      });
    }
    
    window.nmap_script_modal_to_node = (node) => NmapHandlers.handleNodeModal(instance, node);
    window.nmap_start_with_prefill = (rows, params = {}) => NmapHandlers.handlePrefill(instance, rows, params);
  },

  onReset(instance) {
    const prefix = instance.prefix;
    const trace = document.getElementById(`${prefix}trace`);
    if (trace) trace.checked = true;
    const stealth = document.getElementById(`${prefix}stealth`);
    if (stealth) stealth.checked = false;
    const portInput = document.getElementById(`${prefix}portsSelector`);
    if (portInput) portInput.disabled = true;
    instance.state.selectedDatabaseTargets = {};
  },

  getTargets() {
    const tabId = this.getActiveTab();
    if (!tabId) return [];

    if (tabId === 'scope') {
      return { scope_id: this.state.selectedScopeId };
    }

    if (tabId === 'database') {
      const targets = [];
      
      Object.values(this.state.selectedDatabaseTargets).forEach(item => {
        const portsArray = Array.from(item.ports || [])
          .filter(p => p && p !== 'null' && p !== 'undefined' && p !== '');
        
        targets.push({
          ip: item.ip,
          domain: item.domain || '',
          port: portsArray.join(','),
          target: item.ip
        });
      });
      
      return targets;
    }

    if (tabId === 'target') {
      return this.getTargetsFromInputs();
    }

    if (tabId === 'textarea') {
      return this.getTargetsFromTextarea();
    }

    return [];
  },

  async onStart(instance) {
    const scanner = new NmapScanner(instance.prefix);
    try {
      const tabId = instance.getActiveTab();
      let result;

      if (tabId === 'scope') {
        if (!instance.state.selectedScopeId) {
          throw new Error('Please select a scope');
        }
        result = await scanner.scanScope(instance.state.selectedScopeId);
      } else {
        const targets = instance.getTargets();
        if (!targets || targets.length === 0) {
          throw new Error('Please enter at least one target');
        }
        result = await scanner.scanTargets(targets);
      }

      if (result !== null) {
        window[`close_${instance.modalId}`]();
      }
    } catch (error) {
      console.error('Nmap scan error:', error);
      throw error;
    }
  }
});
</script>